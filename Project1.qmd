---
title: "Project 1"
author: "Emma Beardsley and Kevin Krupa"
format:
  html:
    toc: TRUE
    toc-depth: 2
---

# Introduction

Throughout the first couple weeks of this course, we have been learning how to effectively program in R. Many of the topics of discussion revolve around the topic of Data Science, and how to use it to work with data in a way in which almost tells a story. In this project, we will be doing just that. Over the course of this report, we will be working through the process of working with raw data to create clean data sets that can be used to create summaries through plots.

# Packages

For this project, we will be working with raw data to perform cleaning, wrangling, and operations. We will work through this primarily using the tidyverse library, so we will read in this package first.

```{r Libraries, echo = FALSE, warning = FALSE}
library(tidyverse)
```

# Data Processing

As mentioned above, we will be using multiple `.csv` files that contain information obtained from the census bureau. The data is from 2010, and our first goal will be to read in one of these data sets and perform some necessary cleaning/wrangling. There are many variables in this data set, but we will only want to look at *Area_name*, *STCOU*, and any variable that ends in *"D"*. Also, the data is originally in wide-format, but we know that statistical analysis are usually performed on long-format data. So, we will include code that changes the data from wide to long format (each row only has one enrollment value for a specific area name). We will also want to create some new variables here that will be useful later on in the report. The final result of this section will be two data sets: one that contains only non-county data, and one that contains only county-level data.

```{r Data Processing, warning=FALSE, show_col_types = FALSE, message=FALSE}
#Read and make data set with area name, STCOU, Enrollment
Data_1 <- as_tibble(read_csv(file = "https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")) |>
  select("area_name"=Area_name,STCOU,ends_with("D")) |>
  pivot_longer(cols= 3:12, names_to = "Enrollment", values_to = "Enrollment_Number") 

#Create Column that has course and year together
Year_digits <- as.numeric(substr(Data_1$Enrollment, 8, 9))
Year <- as.character(1900+Year_digits)
Course <- substr(Data_1$Enrollment,1,7)
Data_1$Course_Year <- paste0(Course,Year)

#Identify rows for counties
County_entries <- grep(pattern = ", \\w\\w", Data_1$area_name)

#Create,output, and give class to County and State data sets
County <- Data_1[County_entries,]
class(County) <- c("County", class(County))

State <- Data_1[-County_entries,]
class(State) <- c("State", class(State))

#Create State variable for county
County$State_abbr <- substr(County$area_name, nchar(County$area_name)-2, nchar(County$area_name))

#Create Division for state
State <- mutate(State, Division = ifelse(area_name %in% c("CONNECTICUT","MAINE",
"MASSACHUSETTS", "NEW HAMPSHIRE","RHODE ISLAND","VERMONT"),"NEW ENGLAND",
ifelse(area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA"), "MID ATLANTIC",
ifelse(area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"), "EAST NORTH CENTRAL",
ifelse(area_name %in% c("IOWA", "KANSAS", "MINNESOTA","MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA"), "WEST NORTH CENTRAL",
ifelse(area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "WEST VIRGINIA"), "SOUTH ATLANTIC",
ifelse(area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE"), "EAST SOUTH CENTRAL",
ifelse(area_name %in% c("ARKANSAS", "LOISIANA", "OKLAHOMA", "TEXAS"), "WEST SOUTH CENTRAL",
ifelse(area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANTA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"), "MOUNTAIN",
ifelse(area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON"), "PACIFIC", "ERROR"))))))))))

County
State
```

Now that we have successfully parsed through the data set, as described above, we have created our non-county (state) and county-level datasets. In the next section, we will perform the same operations; however, it will be done differently.

# Data Processing/Combination Functions 

## Data Processing Functions

For the second raw data set, we will parse through the data as done before; however, it will be done by using functions to perform each of the steps you saw in the previous section. Using functions allows our code to become more flexible and concise. Instead of writing long sections of code over and over again, we can write a function that performs many operations and use it throughout the program. This concept will be detailed here.

```{r Combing Data Functions, warning=FALSE, show_col_types = FALSE, message=FALSE}
url<-"https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv"
combine_function<-function(url , default_var_name= "Enrollment"){
  #read in data
  Data<-as_tibble(read_csv(file= url)) |>
    
#step 1 and 2
    select("area_name"=Area_name,STCOU,ends_with("D")) |>
  pivot_longer(cols= 3:12, names_to = "Enrollment", values_to = "Enrollment_Number") |>
    
 #step 3
    mutate(Course_Year=paste0(substr(Enrollment,1,7),as.character(1900+(as.numeric(substr(Enrollment, 8, 9)))))) |>
    collect()
  
#step 5
    County<-Data[grep(pattern = ", \\w\\w", Data$area_name),] |>
    mutate(State_abbr=substr(area_name, nchar(area_name)-2, nchar(area_name))) |>
      collect()
    class(County) <- c("County", class(County))

#step 6
 State<-Data[-grep(pattern = ", \\w\\w", Data$area_name),] |>
    mutate(Division = ifelse(area_name %in% c("CONNECTICUT","MAINE","MASSACHUSETTS", "NEW HAMPSHIRE", "RHODE ISLAND","VERMONT"), "NEW ENGLAND", 
ifelse(area_name %in% c("NEW JERSEY", "NEW YORK", "PENNSYLVANIA"), "MID ATLANTIC",
ifelse(area_name %in% c("ILLINOIS", "INDIANA", "MICHIGAN", "OHIO", "WISCONSIN"), "EAST NORTH CENTRAL",
ifelse(area_name %in% c("IOWA", "KANSAS", "MINNESOTA","MISSOURI", "NEBRASKA", "NORTH DAKOTA", "SOUTH DAKOTA"), "WEST NORTH CENTRAL",
ifelse(area_name %in% c("DELAWARE", "FLORIDA", "GEORGIA", "MARYLAND", "NORTH CAROLINA", "SOUTH CAROLINA", "VIRGINIA", "DISTRICT OF COLUMBIA", "WEST VIRGINIA"), "SOUTH ATLANTIC",
ifelse(area_name %in% c("ALABAMA", "KENTUCKY", "MISSISSIPPI", "TENNESSEE"), "EAST SOUTH CENTRAL",
ifelse(area_name %in% c("ARKANSAS", "LOISIANA", "OKLAHOMA", "TEXAS"), "WEST SOUTH CENTRAL",
ifelse(area_name %in% c("ARIZONA", "COLORADO", "IDAHO", "MONTANTA", "NEVADA", "NEW MEXICO", "UTAH", "WYOMING"), "MOUNTAIN",
ifelse(area_name %in% c("ALASKA", "CALIFORNIA", "HAWAII", "OREGON", "WASHINGTON"), "PACIFIC", "ERROR")))))))))) |>
   collect()
 class(State) <- c("State", class(State))
 
 return(list(County,State))

}
```

Now that we have created a function that parses through the data set as needed, we can then apply it to different data sets. This will be detailed in the next section

## Data Combination Function

In this section, we will use our newly created data processing function to read in and parse through the two raw data sets. These two raw data sets are very similar, and we want to be able to combine the non-county and county-level data from each data set. This provides the need to create a new function, that takes in the result of the two calls to the data processing function and combines the two non-county and two county-level data sets. The result of this function should be one object, that holds the combined non-county and county-level data sets.

```{r Combine Data, warning=FALSE, show_col_types = FALSE, message=FALSE}
#Set a and b
urla<- "https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv"
urlb<- "https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv"
Data_a<-combine_function(urla, default_var_name = "Enrollment")
Data_b<-combine_function(urlb, default_var_name = "Enrollment")

#Combine the data for Counties and States
final_combine_function <- function(a, b){
  Counties <- bind_rows(a[[1]], b[[1]])
  class(Counties) <- c("Counties", class(Counties))

  States <- bind_rows(a[[2]], b[[2]])
  class(States) <- c("States", class(States))
  
  combined_data <- list(Counties, States)
  
  return(combined_data)
}

final_combine_function(Data_a, Data_b)

```

Now that we have successfully combined the raw data and created an object to hold the two new data sets, we can now look to create functions for summarizing.

# Generic Functions For Summarizing Data

Since we have our list object with the non-county and county-level data sets , we can look to create functions that produce plots for summarizing important enrollment information. The first function we will create is for the non-county data set. In this function we will produce a plot that expresses the mean value of enrollment across the years for each division. On the x-axis, will be the numeric year value; on the y-axis, will be the mean enrollment number for each division and numeric year. This function will also remove the "ERROR" setting of Division.

```{r}
plot.state <- function(data, var_name = "Enrollment_Number") {
  # Remove the "ERROR" Division setting
  subset_data <- data |>
    filter(Division != "ERROR")
  
  #Obtain the mean enrollment number for each division and numeric year
  mean_values <- subset_data |>
    group_by(Course_Year, Division) |>
    summarize(mean_value = mean(get(var_name), na.rm = TRUE), .groups = 'drop')
  
  #Create the line plot
  g <- ggplot(mean_values, aes(x = Course_Year, y = mean_value, color = Division,
                          group = Division)) +
    geom_line() +
    labs(title = paste("Mean", var_name, "Across Years by Division"),
         x = "Year",
         y = paste("Mean", var_name)) +
    theme(axis.text.x = element_text(angle = 90))
  
  print(g)
}

plot.class_state_df <- function(df, var_name = "Enrollment_Number") {
  plot.state(df, var_name)
}
```

Now, for the County class data set, we will produce a similar function, but with more flexibility. The function will allow the user to input several different arguments: Specify the state of interest (default value will be "NC"); Determine whether we want to look at the "top" or "bottom" counties (default value of "top"); Determine how many of the "top" or "bottom" counties we want to look at (default value of 5).

Within this function, we will find the overall mean of the statistic for each `Area_name` and sort the values from largest to smallest if "top" is specified, or smallest to largest if "bottom" is specified. We will obtain the top or bottom *x* number of area names from the previous step where *x* is one of the arguments the user can specify. Lastly, we will filter the data for this state to only include the area name's from the previous step. This last step will be the data we will use to plot.

```{r}
plot.county <- function(data, var_name = "Enrollment_Number", state = "NC",
                        group = "top", number = 5){
  state <- paste0(" ", state)
  
  #Only include observations from specified state
  subset_data <- data |>
    filter(State_abbr == state) |>
    mutate(Course_Year = substr(Course_Year, nchar(Course_Year) - 3,
                                nchar(Course_Year)))
  
  #Obtain overall mean for statistic for each area name and sort 
  values <- subset_data |>
    group_by(area_name) |>
    summarize(value = mean(get(var_name), na.rm = TRUE), .groups = 'drop') |>
    arrange(if (group == "top") desc(value) else value)
  
  #Get the names of counties we want to look at
  counties <- values |>
    head(number) |>
    pull(area_name)
  
  #Obtain the data we use to plot
  plot_data <- subset_data |>
    filter(area_name %in% counties)
  
  #Create the line plot
  g <- ggplot(plot_data, aes(x = Course_Year, y = get(var_name),
                             color = area_name, group = area_name)) +
    geom_line() +
    labs(title = "Enrollment Number Across Years by County in State",
         x = "Year",
         y = "Enrollment Number") +
    theme(axis.text.x = element_text(angle = 90))
  
  print(g)
}

plot.class_county_df <- function(df, var_name = "Enrollment_Number",
                                 state = "NC", group = "top", number = 5) {
  plot.county(df, var_name, state, group, number)
}
```

Both plotting functions have now been successfully created. In the next section, we will detail the flexibility of these functions and see how they work on multiple different raw .csv files.

# Putting It All Together

In the last section of this report, we will be putting all of the previous sections together to show the usage of our functions across multiple raw data sets. To start, we will run our data processing function on the two census bureau data urls we used above. Then, we will run our combination function to combine these two raw data sets to create one object that holds our non-county and county-level data sets.

```{r, message = FALSE}
urla <- "https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv"
EDU01a <- combine_function(urla, default_var_name = "Enrollment")

urlb <- "https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv"
EDU01b <- combine_function(urlb, default_var_name = "Enrollment")

EDU01 <- final_combine_function(EDU01a, EDU01b)
EDU01
```

Now, we will make use of our summarizing functions that creates plots. We run these functions multiple times, specifying different values to our arguments to check the flexibility of the functions.

```{r}
class_county_df <- EDU01[[1]]
class(class_county_df) <- c("class_county_df", class(class_county_df))
class_state_df  <- EDU01[[2]]
class(class_state_df) <- c("class_state_df", class(class_state_df))

plot(class_state_df)
plot(class_county_df, state = "NC", group = "top", number = 20)
plot(class_county_df, state = "SC", group = "bottom", number = 7)
plot(class_county_df)
plot(class_county_df, state = "PA", group = "top", number = 8)
```

We are now going to try our functions on similar data sets. To start, we will read in and use our data processing function on four different raw data sets.

```{r, message = FALSE}
urla <- "https://www4.stat.ncsu.edu/~online/datasets/PST01a.csv"
PST01a <- combine_function(urla, default_var_name = "Enrollment")

urlb <- "https://www4.stat.ncsu.edu/~online/datasets/PST01b.csv"
PST01b <- combine_function(urlb, default_var_name = "Enrollment")

urlc <- "https://www4.stat.ncsu.edu/~online/datasets/PST01c.csv"
PST01c <- combine_function(urlc, default_var_name = "Enrollment")

urld <- "https://www4.stat.ncsu.edu/~online/datasets/PST01d.csv"
PST01d <- combine_function(urld, default_var_name = "Enrollment")
```

After successfully reading in and parsing our data, we can use our combination function multiple times to get all four data sets into one, and create two final two class data sets.

```{r}
combine_1 <- final_combine_function(PST01a, PST01b)
combine_2 <- final_combine_function(combine_1, PST01c)
PST01     <- final_combine_function(combine_2, PST01d)

PST01
```

Finally, let's run our summarizing functions with different specifications to once again check the flexibility of the functions.

```{r}
class_county_df <- PST01[[1]]
class(class_county_df) <- c("class_county_df", class(class_county_df))
class_state_df  <- PST01[[2]]
class(class_state_df) <- c("class_state_df", class(class_state_df))

plot(class_state_df)
plot(class_county_df, state = "CA", number = 15)
plot(class_county_df, state = "TX", number = 4)
plot(class_county_df)
plot(class_county_df, state = "NY", number = 10)
```
